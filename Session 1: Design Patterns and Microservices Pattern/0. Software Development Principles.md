# Software Development Principles

## SOLID Principles

### 1. Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should have only one job or responsibility.

**Java Example:**

```java
// Before SRP: Class handling multiple responsibilities
class Invoice {
    void calculateTotal() { /* ... */ }
    void printInvoice() { /* ... */ }
    void saveToDatabase() { /* ... */ }
}

// After SRP: Separate classes for each responsibility
class Invoice {
    void calculateTotal() { /* ... */ }
}

class InvoicePrinter {
    void printInvoice(Invoice invoice) { /* ... */ }
}

class InvoiceRepository {
    void save(Invoice invoice) { /* ... */ }
}
```

**Consequences of Not Following SRP:**
- **Increased Complexity:** The class becomes complex with multiple responsibilities, making it harder to understand and maintain.
- **Difficult to Modify:** Changes in one responsibility may affect others, causing unintended side effects and making the class brittle.
- **Harder to Test:** Testing becomes more challenging as multiple responsibilities need to be verified together.

### 2. Open/Closed Principle (OCP)
Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

**Java Example:**

```java
// Before OCP: Modifying the existing class to add new functionality
class PaymentProcessor {
    void processPayment(String type) {
        if (type.equals("CreditCard")) {
            // process credit card payment
        } else if (type.equals("PayPal")) {
            // process PayPal payment
        }
    }
}

// After OCP: Extending the functionality without modifying the existing class
abstract class Payment {
    abstract void process();
}

class CreditCardPayment extends Payment {
    void process() { /* ... */ }
}

class PayPalPayment extends Payment {
    void process() { /* ... */ }
}

class PaymentProcessor {
    void processPayment(Payment payment) {
        payment.process();
    }
}
```

**Consequences of Not Following OCP:**
- **Fragile Code:** Modifications to existing code can introduce bugs and unintended side effects.
- **Tight Coupling:** Classes become tightly coupled to specific implementations, reducing flexibility and increasing maintenance costs.
- **Difficulty in Extending:** Adding new features requires modifying existing code, which can lead to increased risk of errors.

### 3. Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

**Java Example:**

```java
// Before LSP: Subclass violates the behavior expected by the superclass
class Bird {
    void fly() { /* ... */ }
}

class Ostrich extends Bird {
    void fly() { 
        throw new UnsupportedOperationException("Ostrich can't fly");
    }
}

// After LSP: Separate classes to ensure correct behavior
class Bird { }

class FlyingBird extends Bird {
    void fly() { /* ... */ }
}

class Ostrich extends Bird { /* Ostrich-specific methods */ }
```

**Consequences of Not Following LSP:**
- **Unexpected Behavior:** Subclasses can introduce unexpected behaviors, leading to runtime errors and instability.
- **Difficult to Refactor:** Refactoring code becomes challenging if subclasses do not conform to expected behaviors.
- **Reduced Reusability:** Code relying on the superclass may not work correctly with subclasses, reducing the reusability of code.

### 4. Interface Segregation Principle (ISP)
Clients should not be forced to implement interfaces they do not use. Instead, multiple specific interfaces are better than one general-purpose interface.

**Java Example:**

```java
// Before ISP: One general interface with methods not needed by all clients
interface Worker {
    void work();
    void eat();
}

class HumanWorker implements Worker {
    public void work() { /* ... */ }
    public void eat() { /* ... */ }
}

class RobotWorker implements Worker {
    public void work() { /* ... */ }
    public void eat() { 
        // Not applicable for robots
    }
}

// After ISP: Separate interfaces for specific behaviors
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class HumanWorker implements Workable, Eatable {
    public void work() { /* ... */ }
    public void eat() { /* ... */ }
}

class RobotWorker implements Workable {
    public void work() { /* ... */ }
}
```

**Consequences of Not Following ISP:**
- **Unnecessary Implementations:** Clients are forced to implement methods they do not need, leading to unnecessary code and complexity.
- **Increased Coupling:** Changes to the interface may force changes in clients that do not require the new functionality.
- **Difficult to Maintain:** Large interfaces can become cumbersome to maintain and evolve.

### 5. Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

**Java Example:**

```java
// Before DIP: High-level module depends on a low-level module
class Lamp {
    void turnOn() { /* ... */ }
}

class Switch {
    private Lamp lamp;
    Switch(Lamp lamp) {
        this.lamp = lamp;
    }
    void operate() {
        lamp.turnOn();
    }
}

// After DIP: High-level module depends on an abstraction
interface Switchable {
    void turnOn();
}

class Lamp implements Switchable {
    public void turnOn() { /* ... */ }
}

class Switch {
    private Switchable device;
    Switch(Switchable device) {
        this.device = device;
    }
    void operate() {
        device.turnOn();
    }
}
```

**Consequences of Not Following DIP:**
- **Tight Coupling:** High-level modules become tightly coupled to low-level modules, reducing flexibility and making the system harder to change.
- **Difficulty in Testing:** Testing high-level modules becomes challenging as they are dependent on concrete implementations.
- **Increased Rigidity:** Changes in low-level modules require modifications in high-level modules, leading to a brittle codebase.
