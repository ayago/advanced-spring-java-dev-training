# Software Development Principles

## SOLID Principles

### 1. Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should have only one job or responsibility.

**Java Example:**

```java
// Before SRP: Class handling multiple responsibilities
class Invoice {
    void calculateTotal() { /* ... */ }
    void printInvoice() { /* ... */ }
    void saveToDatabase() { /* ... */ }
}

// After SRP: Separate classes for each responsibility
class Invoice {
    void calculateTotal() { /* ... */ }
}

class InvoicePrinter {
    void printInvoice(Invoice invoice) { /* ... */ }
}

class InvoiceRepository {
    void save(Invoice invoice) { /* ... */ }
}
```

### 2. Open/Closed Principle (OCP)
Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

**Java Example:**

```java
// Before OCP: Modifying the existing class to add new functionality
class PaymentProcessor {
    void processPayment(String type) {
        if (type.equals("CreditCard")) {
            // process credit card payment
        } else if (type.equals("PayPal")) {
            // process PayPal payment
        }
    }
}

// After OCP: Extending the functionality without modifying the existing class
abstract class Payment {
    abstract void process();
}

class CreditCardPayment extends Payment {
    void process() { /* ... */ }
}

class PayPalPayment extends Payment {
    void process() { /* ... */ }
}

class PaymentProcessor {
    void processPayment(Payment payment) {
        payment.process();
    }
}
```

### 3. Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

**Java Example:**

```java
// Before LSP: Subclass violates the behavior expected by the superclass
class Bird {
    void fly() { /* ... */ }
}

class Ostrich extends Bird {
    void fly() { 
        throw new UnsupportedOperationException("Ostrich can't fly");
    }
}

// After LSP: Separate classes to ensure correct behavior
class Bird { }

class FlyingBird extends Bird {
    void fly() { /* ... */ }
}

class Ostrich extends Bird { /* Ostrich-specific methods */ }
```

### 4. Interface Segregation Principle (ISP)
Clients should not be forced to implement interfaces they do not use. Instead, multiple specific interfaces are better than one general-purpose interface.

**Java Example:**

```java
// Before ISP: One general interface with methods not needed by all clients
interface Worker {
    void work();
    void eat();
}

class HumanWorker implements Worker {
    public void work() { /* ... */ }
    public void eat() { /* ... */ }
}

class RobotWorker implements Worker {
    public void work() { /* ... */ }
    public void eat() { 
        // Not applicable for robots
    }
}

// After ISP: Separate interfaces for specific behaviors
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class HumanWorker implements Workable, Eatable {
    public void work() { /* ... */ }
    public void eat() { /* ... */ }
}

class RobotWorker implements Workable {
    public void work() { /* ... */ }
}
```

### 5. Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

**Java Example:**

```java
// Before DIP: High-level module depends on a low-level module
class Lamp {
    void turnOn() { /* ... */ }
}

class Switch {
    private Lamp lamp;
    Switch(Lamp lamp) {
        this.lamp = lamp;
    }
    void operate() {
        lamp.turnOn();
    }
}

// After DIP: High-level module depends on an abstraction
interface Switchable {
    void turnOn();
}

class Lamp implements Switchable {
    public void turnOn() { /* ... */ }
}

class Switch {
    private Switchable device;
    Switch(Switchable device) {
        this.device = device;
    }
    void operate() {
        device.turnOn();
    }
}
```