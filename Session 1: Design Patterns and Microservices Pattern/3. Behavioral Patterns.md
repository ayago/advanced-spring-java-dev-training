# Behavioral Patterns

Behavioral patterns are concerned with algorithms and theassignment of
responsibilities between objects. Behavioral patterns describe not just patterns
of objects or classes but also the patterns of communication between them. These
patterns characterize complex control flow that's difficult to follow at run-time.
They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected.

## Chain of Responsibility

A behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**When to Use:**

* When you have multiple objects that can handle a request but the exact handler isnâ€™t known in advance.
* When you want to avoid tight coupling between a sender and multiple receivers.
* When you want to execute different operations in sequence on an event but in a loosely coupled manner.

**How to Implement:**

1. Define a Handler Interface: Create an interface or abstract class defining a method to process the request and a reference to the next handler.
2. Concrete Handlers: Implement concrete classes for each type of handler in the chain. Each handler decides whether to process the request or pass it to the next handler.
3. Client: The client initiates the request and passes it to the first handler in the chain.
4. Chain Setup: Link handlers together in the desired order.

**Sample Implementation**

An eCommerce system must decide the appropriate delivery channel for an order based on its properties.

```java
// Order Interface
interface Order {
    boolean isStandardEligible();
    boolean isExpressEligible();
    boolean isInternational();
}

// MockOrder Class
class MockOrder implements Order {
    private boolean standardEligible;
    private boolean expressEligible;
    private boolean international;

    public MockOrder(boolean standardEligible, boolean expressEligible, boolean international) {
        this.standardEligible = standardEligible;
        this.expressEligible = expressEligible;
        this.international = international;
    }

    @Override
    public boolean isStandardEligible() {
        return standardEligible;
    }

    @Override
    public boolean isExpressEligible() {
        return expressEligible;
    }

    @Override
    public boolean isInternational() {
        return international;
    }
}

// Abstract Handler Class
abstract class DeliveryChannelHandler {
    private DeliveryChannelHandler next;

    public void setNextHandler(DeliveryChannelHandler next) {
        this.next = next;
    }

    public void handle(Order order) {
        if (canHandle(order)) {
            doHandle(order);
        } else if (next != null) {
            next.handle(order);
        } else {
            System.out.println("No suitable delivery channel found.");
        }
    }

    protected abstract boolean canHandle(Order order);
    protected abstract void doHandle(Order order);
}

// Concrete Handlers

class StandardDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isStandardEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Standard Delivery.");
    }
}

class ExpressDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isExpressEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Express Delivery.");
    }
}

class InternationalShippingHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isInternational();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via International Shipping.");
    }
}

// DeliveryChannelChain Class
class DeliveryChannelChain {
    private DeliveryChannelHandler firstHandler;

    public DeliveryChannelChain(DeliveryChannelHandler... handlers) {
        if (handlers.length > 0) {
            this.firstHandler = handlers[0];
            DeliveryChannelHandler current = firstHandler;

            for (int i = 1; i < handlers.length; i++) {
                current.setNextHandler(handlers[i]);
                current = handlers[i];
            }
        }
    }

    public DeliveryChannelHandler getChainedHandler(){
        return this.firstHandler;
    }
}

// Client - Name the file ECommerceDelivery.java to execute this sample
public class ECommerceDelivery {
    public static void main(String[] args) {
        
        DeliveryChannelChain deliveryChain = new DeliveryChannelChain(
            new StandardDeliveryHandler(), 
            new ExpressDeliveryHandler(), 
            new InternationalShippingHandler()
        );

        Order order = new MockOrder(false, true, false); // Mock order

        deliveryChain.getChainedHandler().handle(order); // Start the decision chain
    }
}

```

**Real-World Examples:**

* Customer Support System: An email sent to customer support may pass through various levels of support (e.g., Level 1, Level 2, Technical Support) until the issue is resolved.
* Logging Framework: In a logging framework, log requests may pass through different loggers (console, file, database) until one of them handles the logging request.
* Spring Security Filters

**Considerations:**

* Performance: If the chain is too long, it may introduce latency, especially if each handler performs an expensive operation.
* Order Dependency: The order of handlers in the chain is crucial as it directly affects the outcome. The wrong order may lead to improper handling of requests.
* Flexible but Potentially Hard to Trace: While decoupling makes the system more flexible, it can make debugging harder since the request could be handled by any handler in the chain.