# Behavioral Patterns

Behavioral patterns are concerned with algorithms and theassignment of
responsibilities between objects. Behavioral patterns describe not just patterns
of objects or classes but also the patterns of communication between them. These
patterns characterize complex control flow that's difficult to follow at run-time.
They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected.

## Chain of Responsibility

A behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**When to Use:**

* When you have multiple objects that can handle a request but the exact handler isn’t known in advance.
* When you want to avoid tight coupling between a sender and multiple receivers.
* When you want to execute different operations in sequence on an event but in a loosely coupled manner.

**How to Implement:**

1. Define a Handler Interface: Create an interface or abstract class defining a method to process the request and a reference to the next handler.
2. Concrete Handlers: Implement concrete classes for each type of handler in the chain. Each handler decides whether to process the request or pass it to the next handler.
3. Client: The client initiates the request and passes it to the first handler in the chain.
4. Chain Setup: Link handlers together in the desired order.

**Sample Implementation**

An eCommerce system must decide the appropriate delivery channel for an order based on its properties.

```java
// Order Interface
interface Order {
    boolean isStandardEligible();
    boolean isExpressEligible();
    boolean isInternational();
}

// MockOrder Class
class MockOrder implements Order {
    private boolean standardEligible;
    private boolean expressEligible;
    private boolean international;

    public MockOrder(boolean standardEligible, boolean expressEligible, boolean international) {
        this.standardEligible = standardEligible;
        this.expressEligible = expressEligible;
        this.international = international;
    }

    @Override
    public boolean isStandardEligible() {
        return standardEligible;
    }

    @Override
    public boolean isExpressEligible() {
        return expressEligible;
    }

    @Override
    public boolean isInternational() {
        return international;
    }
}

// Abstract Handler Class
abstract class DeliveryChannelHandler {
    private DeliveryChannelHandler next;

    public void setNextHandler(DeliveryChannelHandler next) {
        this.next = next;
    }

    public void handle(Order order) {
        if (canHandle(order)) {
            doHandle(order);
        } else if (next != null) {
            next.handle(order);
        } else {
            System.out.println("No suitable delivery channel found.");
        }
    }

    protected abstract boolean canHandle(Order order);
    protected abstract void doHandle(Order order);
}

// Concrete Handlers

class StandardDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isStandardEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Standard Delivery.");
    }
}

class ExpressDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isExpressEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Express Delivery.");
    }
}

class InternationalShippingHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isInternational();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via International Shipping.");
    }
}

// DeliveryChannelChain Class
class DeliveryChannelChain {
    private DeliveryChannelHandler firstHandler;

    public DeliveryChannelChain(DeliveryChannelHandler... handlers) {
        if (handlers.length > 0) {
            this.firstHandler = handlers[0];
            DeliveryChannelHandler current = firstHandler;

            for (int i = 1; i < handlers.length; i++) {
                current.setNextHandler(handlers[i]);
                current = handlers[i];
            }
        }
    }

    public DeliveryChannelHandler getChainedHandler(){
        return this.firstHandler;
    }
}

// Client - Name the file ECommerceDelivery.java to execute this sample
public class ECommerceDelivery {
    public static void main(String[] args) {
        
        DeliveryChannelChain deliveryChain = new DeliveryChannelChain(
            new StandardDeliveryHandler(), 
            new ExpressDeliveryHandler(), 
            new InternationalShippingHandler()
        );

        Order order = new MockOrder(false, true, false); // Mock order

        deliveryChain.getChainedHandler().handle(order); // Start the decision chain
    }
}

```

**Real-World Examples:**

* Customer Support System: An email sent to customer support may pass through various levels of support (e.g., Level 1, Level 2, Technical Support) until the issue is resolved.
* Logging Framework: In a logging framework, log requests may pass through different loggers (console, file, database) until one of them handles the logging request.
* Spring Security Filters

**Considerations:**

* Performance: If the chain is too long, it may introduce latency, especially if each handler performs an expensive operation.
* Order Dependency: The order of handlers in the chain is crucial as it directly affects the outcome. The wrong order may lead to improper handling of requests.
* Flexible but Potentially Hard to Trace: While decoupling makes the system more flexible, it can make debugging harder since the request could be handled by any handler in the chain.

## Command

Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request’s execution, and support undoable operations.

**When to Use**

* You need to parameterize objects with operations.
* You want to queue, log, schedule, or provide undo functionality for operations.
* You want to decouple the sender of a request from the object that performs the action.

**How to Implement**

1. Command Interface: Define a command interface with a method for executing the command.
2. Concrete Command: Implement the command interface for each specific operation.
Receiver: Implement the actual logic that performs the operation.
3. Invoker: This class triggers the command execution.
4. Client/Application: The client creates the command object, sets the receiver, and passes the command to the invoker.

**Sample Implementation**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Command Interface
interface Command {
    void execute();
}

// Receiver
class InventoryService {
    public void addItem(String item) {
        System.out.println("Item " + item + " added to inventory.");
    }

    public void removeItem(String item) {
        System.out.println("Item " + item + " removed from inventory.");
    }
}

// Concrete Command for Adding Item
class AddItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public AddItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.addItem(item);
    }
}

// Concrete Command for Removing Item
class RemoveItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public RemoveItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.removeItem(item);
    }
}

// Invoker
class InventoryManager {
    private ExecutorService executorService;

    public InventoryManager(int threadPoolSize) {
        this.executorService = Executors.newFixedThreadPool(threadPoolSize);
    }

    public void executeCommand(Command command) {
        executorService.submit(() -> {
            command.execute();
        });
    }

    // Gracefully shut down the executor service when done
    public void shutdown() {
        executorService.shutdown();
    }
}

// Client/Application
public class ECommerceApp {
    public static void main(String[] args) {
        InventoryService inventoryService = new InventoryService();
        Command addCommand = new AddItemCommand(inventoryService, "Laptop");
        Command removeCommand = new RemoveItemCommand(inventoryService, "Laptop");

        // Create InventoryManager with a thread pool of size 2
        InventoryManager manager = new InventoryManager(2);

        // Execute commands asynchronously
        manager.executeCommand(addCommand);
        manager.executeCommand(removeCommand);

        // Shutdown the executor when done
        manager.shutdown();
    }
}

```

**Real World Examples**

* GUI Frameworks: Buttons and menu items in graphical user interfaces often use Command patterns to handle user actions like opening files or saving documents.
* Task Scheduling: In scheduling systems, tasks are encapsulated as commands and then executed by a task scheduler.
* The Java Runnable interface

**Considerations**

* Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.
* Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.
* You can implement undo/redo.
* You can implement deferred execution of operations.
* You can assemble a set of simple commands into a complex one.
* The code may become more complicated since you’re introducing a whole new layer between senders and receivers.

## Iterator

The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

**When to Use**

When you need to traverse a collection of objects without exposing the internal structure.
When multiple types of collections need to be iterated in a uniform way.
When different traversal algorithms are required for different data structures.

**How to Implement**

1. Define the Iterator Interface: Define an interface with methods like hasNext(), next(), and optionally remove().
2. Concrete Iterator: Implement the iterator interface for specific collections.
3. Aggregate Interface: Create an interface to define a method that returns an iterator, e.g., createIterator().
4. Concrete Aggregate: Implement the aggregate interface, which returns the specific iterator for the collection.

**Sample Implementation**

```java
import java.util.*;

// Iterator Interface
public interface InventoryIterator extends AutoCloseable {
    boolean hasNext();
    InventoryItem next();
    @Override
    void close();
}

// Concrete Iterator for Event Stream
public class EventStreamIterator implements InventoryIterator {
    private Queue<InventoryItem> eventStream;

    public EventStreamIterator(Queue<InventoryItem> eventStream) {
        this.eventStream = eventStream;
    }

    @Override
    public boolean hasNext() {
        return !eventStream.isEmpty();
    }

    @Override
    public InventoryItem next() {
        return eventStream.poll();
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("EventStreamIterator: Closing resources.");
    }
}

// Concrete Iterator for Bulk Fetch
public class BulkFetchIterator implements InventoryIterator {
    private List<InventoryItem> items;
    private int currentPosition = 0;

    public BulkFetchIterator(List<InventoryItem> items) {
        this.items = items;
    }

    @Override
    public boolean hasNext() {
        return currentPosition < items.size();
    }

    @Override
    public InventoryItem next() {
        return items.get(currentPosition++);
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("BulkFetchIterator: Closing resources.");
    }
}

// Aggregate Interface
public interface InventoryAggregate {
    InventoryIterator createIterator();
}

// Concrete Aggregate for Event Stream
public class EventStreamInventory implements InventoryAggregate {
    private Queue<InventoryItem> eventStream = new LinkedList<>();

    public void addEvent(InventoryItem item) {
        eventStream.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new EventStreamIterator(eventStream);
    }
}

// Concrete Aggregate for Bulk Fetch
public class BulkFetchInventory implements InventoryAggregate {
    private List<InventoryItem> items = new ArrayList<>();

    public void addItem(InventoryItem item) {
        items.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new BulkFetchIterator(items);
    }
}

// InventoryItem Class
public class InventoryItem {
    private String name;
    private int quantity;

    public InventoryItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Item: " + name + ", Quantity: " + quantity;
    }
}

// Main Class to demonstrate the Iterator pattern
public class InventoryOnboardingSystem {
    public static void main(String[] args) {
        // Setup Event Stream Inventory
        EventStreamInventory eventStreamInventory = new EventStreamInventory();
        eventStreamInventory.addEvent(new InventoryItem("Laptop", 50));
        eventStreamInventory.addEvent(new InventoryItem("Smartphone", 200));
        eventStreamInventory.addEvent(new InventoryItem("Tablet", 100));

        // Setup Bulk Fetch Inventory
        BulkFetchInventory bulkFetchInventory = new BulkFetchInventory();
        bulkFetchInventory.addItem(new InventoryItem("Monitor", 75));
        bulkFetchInventory.addItem(new InventoryItem("Keyboard", 150));
        bulkFetchInventory.addItem(new InventoryItem("Mouse", 300));

        // Process Event Stream Inventory
        System.out.println("Processing Event Stream Inventory:");
        try (InventoryIterator eventStreamIterator = eventStreamInventory.createIterator()) {
            while (eventStreamIterator.hasNext()) {
                InventoryItem item = eventStreamIterator.next();
                System.out.println(item);
            }
        }

        // Process Bulk Fetch Inventory
        System.out.println("\nProcessing Bulk Fetch Inventory:");
        try (InventoryIterator bulkFetchIterator = bulkFetchInventory.createIterator()) {
            while (bulkFetchIterator.hasNext()) {
                InventoryItem item = bulkFetchIterator.next();
                System.out.println(item);
            }
        }
    }
}

```

**Real World Example**

* Java’s java.util.Iterator: The standard library’s Iterator is a classic example. It’s used to traverse collections like List, Set, etc., without exposing their internal structures.
* Apache Kafka Consumer: The consumer API provides an iterator-like mechanism to traverse records from a Kafka topic.

**Considerations**

* Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.
* Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.
* You can iterate over the same collection in parallel because each iterator object contains its own iteration state.
* For the same reason, you can delay an iteration and continue it when needed.
* Applying the pattern can be an overkill if your app only works with simple collections.
* Using an iterator may be less efficient than going through elements of some specialized collections directly.