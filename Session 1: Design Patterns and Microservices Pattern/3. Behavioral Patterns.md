# Behavioral Patterns

Behavioral patterns are concerned with algorithms and theassignment of
responsibilities between objects. Behavioral patterns describe not just patterns
of objects or classes but also the patterns of communication between them. These
patterns characterize complex control flow that's difficult to follow at run-time.
They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected.

## Chain of Responsibility

A behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**When to Use:**

* When you have multiple objects that can handle a request but the exact handler isn’t known in advance.
* When you want to avoid tight coupling between a sender and multiple receivers.
* When you want to execute different operations in sequence on an event but in a loosely coupled manner.

**How to Implement:**

1. Define a Handler Interface: Create an interface or abstract class defining a method to process the request and a reference to the next handler.
2. Concrete Handlers: Implement concrete classes for each type of handler in the chain. Each handler decides whether to process the request or pass it to the next handler.
3. Client: The client initiates the request and passes it to the first handler in the chain.
4. Chain Setup: Link handlers together in the desired order.

**Sample Implementation**

An eCommerce system must decide the appropriate delivery channel for an order based on its properties.

```java
// Order Interface
interface Order {
    boolean isStandardEligible();
    boolean isExpressEligible();
    boolean isInternational();
}

// MockOrder Class
class MockOrder implements Order {
    private boolean standardEligible;
    private boolean expressEligible;
    private boolean international;

    public MockOrder(boolean standardEligible, boolean expressEligible, boolean international) {
        this.standardEligible = standardEligible;
        this.expressEligible = expressEligible;
        this.international = international;
    }

    @Override
    public boolean isStandardEligible() {
        return standardEligible;
    }

    @Override
    public boolean isExpressEligible() {
        return expressEligible;
    }

    @Override
    public boolean isInternational() {
        return international;
    }
}

// Abstract Handler Class
abstract class DeliveryChannelHandler {
    private DeliveryChannelHandler next;

    public void setNextHandler(DeliveryChannelHandler next) {
        this.next = next;
    }

    public void handle(Order order) {
        if (canHandle(order)) {
            doHandle(order);
        } else if (next != null) {
            next.handle(order);
        } else {
            System.out.println("No suitable delivery channel found.");
        }
    }

    protected abstract boolean canHandle(Order order);
    protected abstract void doHandle(Order order);
}

// Concrete Handlers

class StandardDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isStandardEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Standard Delivery.");
    }
}

class ExpressDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isExpressEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Express Delivery.");
    }
}

class InternationalShippingHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isInternational();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via International Shipping.");
    }
}

// DeliveryChannelChain Class
class DeliveryChannelChain {
    private DeliveryChannelHandler firstHandler;

    public DeliveryChannelChain(DeliveryChannelHandler... handlers) {
        if (handlers.length > 0) {
            this.firstHandler = handlers[0];
            DeliveryChannelHandler current = firstHandler;

            for (int i = 1; i < handlers.length; i++) {
                current.setNextHandler(handlers[i]);
                current = handlers[i];
            }
        }
    }

    public DeliveryChannelHandler getChainedHandler(){
        return this.firstHandler;
    }
}

// Client - Name the file ECommerceDelivery.java to execute this sample
public class ECommerceDelivery {
    public static void main(String[] args) {
        
        DeliveryChannelChain deliveryChain = new DeliveryChannelChain(
            new StandardDeliveryHandler(), 
            new ExpressDeliveryHandler(), 
            new InternationalShippingHandler()
        );

        Order order = new MockOrder(false, true, false); // Mock order

        deliveryChain.getChainedHandler().handle(order); // Start the decision chain
    }
}

```

**Real-World Examples:**

* Customer Support System: An email sent to customer support may pass through various levels of support (e.g., Level 1, Level 2, Technical Support) until the issue is resolved.
* Logging Framework: In a logging framework, log requests may pass through different loggers (console, file, database) until one of them handles the logging request.
* Spring Security Filters

**Considerations:**

* Performance: If the chain is too long, it may introduce latency, especially if each handler performs an expensive operation.
* Order Dependency: The order of handlers in the chain is crucial as it directly affects the outcome. The wrong order may lead to improper handling of requests.
* Flexible but Potentially Hard to Trace: While decoupling makes the system more flexible, it can make debugging harder since the request could be handled by any handler in the chain.

## Command

Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request’s execution, and support undoable operations.

**When to Use**

* You need to parameterize objects with operations.
* You want to queue, log, schedule, or provide undo functionality for operations.
* You want to decouple the sender of a request from the object that performs the action.

**How to Implement**

1. Command Interface: Define a command interface with a method for executing the command.
2. Concrete Command: Implement the command interface for each specific operation.
Receiver: Implement the actual logic that performs the operation.
3. Invoker: This class triggers the command execution.
4. Client/Application: The client creates the command object, sets the receiver, and passes the command to the invoker.

**Sample Implementation**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Command Interface
interface Command {
    void execute();
}

// Receiver
class InventoryService {
    public void addItem(String item) {
        System.out.println("Item " + item + " added to inventory.");
    }

    public void removeItem(String item) {
        System.out.println("Item " + item + " removed from inventory.");
    }
}

// Concrete Command for Adding Item
class AddItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public AddItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.addItem(item);
    }
}

// Concrete Command for Removing Item
class RemoveItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public RemoveItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.removeItem(item);
    }
}

// Invoker
class InventoryManager {
    private ExecutorService executorService;

    public InventoryManager(int threadPoolSize) {
        this.executorService = Executors.newFixedThreadPool(threadPoolSize);
    }

    public void executeCommand(Command command) {
        executorService.submit(() -> {
            command.execute();
        });
    }

    // Gracefully shut down the executor service when done
    public void shutdown() {
        executorService.shutdown();
    }
}

// Client/Application
public class ECommerceApp {
    public static void main(String[] args) {
        InventoryService inventoryService = new InventoryService();
        Command addCommand = new AddItemCommand(inventoryService, "Laptop");
        Command removeCommand = new RemoveItemCommand(inventoryService, "Laptop");

        // Create InventoryManager with a thread pool of size 2
        InventoryManager manager = new InventoryManager(2);

        // Execute commands asynchronously
        manager.executeCommand(addCommand);
        manager.executeCommand(removeCommand);

        // Shutdown the executor when done
        manager.shutdown();
    }
}

```

**Real World Examples**

* GUI Frameworks: Buttons and menu items in graphical user interfaces often use Command patterns to handle user actions like opening files or saving documents.
* Task Scheduling: In scheduling systems, tasks are encapsulated as commands and then executed by a task scheduler.
* The Java Runnable interface

**Considerations**

* Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.
* Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.
* You can implement undo/redo.
* You can implement deferred execution of operations.
* You can assemble a set of simple commands into a complex one.
* The code may become more complicated since you’re introducing a whole new layer between senders and receivers.

## Iterator

The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

**When to Use**

When you need to traverse a collection of objects without exposing the internal structure.
When multiple types of collections need to be iterated in a uniform way.
When different traversal algorithms are required for different data structures.

**How to Implement**

1. Define the Iterator Interface: Define an interface with methods like hasNext(), next(), and optionally remove().
2. Concrete Iterator: Implement the iterator interface for specific collections.
3. Aggregate Interface: Create an interface to define a method that returns an iterator, e.g., createIterator().
4. Concrete Aggregate: Implement the aggregate interface, which returns the specific iterator for the collection.

**Sample Implementation**

```java
import java.util.*;

// Iterator Interface
public interface InventoryIterator extends AutoCloseable {
    boolean hasNext();
    InventoryItem next();
    @Override
    void close();
}

// Concrete Iterator for Event Stream
public class EventStreamIterator implements InventoryIterator {
    private Queue<InventoryItem> eventStream;

    public EventStreamIterator(Queue<InventoryItem> eventStream) {
        this.eventStream = eventStream;
    }

    @Override
    public boolean hasNext() {
        return !eventStream.isEmpty();
    }

    @Override
    public InventoryItem next() {
        return eventStream.poll();
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("EventStreamIterator: Closing resources.");
    }
}

// Concrete Iterator for Bulk Fetch
public class BulkFetchIterator implements InventoryIterator {
    private List<InventoryItem> items;
    private int currentPosition = 0;

    public BulkFetchIterator(List<InventoryItem> items) {
        this.items = items;
    }

    @Override
    public boolean hasNext() {
        return currentPosition < items.size();
    }

    @Override
    public InventoryItem next() {
        return items.get(currentPosition++);
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("BulkFetchIterator: Closing resources.");
    }
}

// Aggregate Interface
public interface InventoryAggregate {
    InventoryIterator createIterator();
}

// Concrete Aggregate for Event Stream
public class EventStreamInventory implements InventoryAggregate {
    private Queue<InventoryItem> eventStream = new LinkedList<>();

    public void addEvent(InventoryItem item) {
        eventStream.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new EventStreamIterator(eventStream);
    }
}

// Concrete Aggregate for Bulk Fetch
public class BulkFetchInventory implements InventoryAggregate {
    private List<InventoryItem> items = new ArrayList<>();

    public void addItem(InventoryItem item) {
        items.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new BulkFetchIterator(items);
    }
}

// InventoryItem Class
public class InventoryItem {
    private String name;
    private int quantity;

    public InventoryItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Item: " + name + ", Quantity: " + quantity;
    }
}

// Main Class to demonstrate the Iterator pattern
public class InventoryOnboardingSystem {
    public static void main(String[] args) {
        // Setup Event Stream Inventory
        EventStreamInventory eventStreamInventory = new EventStreamInventory();
        eventStreamInventory.addEvent(new InventoryItem("Laptop", 50));
        eventStreamInventory.addEvent(new InventoryItem("Smartphone", 200));
        eventStreamInventory.addEvent(new InventoryItem("Tablet", 100));

        // Setup Bulk Fetch Inventory
        BulkFetchInventory bulkFetchInventory = new BulkFetchInventory();
        bulkFetchInventory.addItem(new InventoryItem("Monitor", 75));
        bulkFetchInventory.addItem(new InventoryItem("Keyboard", 150));
        bulkFetchInventory.addItem(new InventoryItem("Mouse", 300));

        // Process Event Stream Inventory
        System.out.println("Processing Event Stream Inventory:");
        try (InventoryIterator eventStreamIterator = eventStreamInventory.createIterator()) {
            while (eventStreamIterator.hasNext()) {
                InventoryItem item = eventStreamIterator.next();
                System.out.println(item);
            }
        }

        // Process Bulk Fetch Inventory
        System.out.println("\nProcessing Bulk Fetch Inventory:");
        try (InventoryIterator bulkFetchIterator = bulkFetchInventory.createIterator()) {
            while (bulkFetchIterator.hasNext()) {
                InventoryItem item = bulkFetchIterator.next();
                System.out.println(item);
            }
        }
    }
}

```

**Real World Example**

* Java’s java.util.Iterator: The standard library’s Iterator is a classic example. It’s used to traverse collections like List, Set, etc., without exposing their internal structures.
* Apache Kafka Consumer: The consumer API provides an iterator-like mechanism to traverse records from a Kafka topic.

**Considerations**

* Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.
* Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.
* You can iterate over the same collection in parallel because each iterator object contains its own iteration state.
* For the same reason, you can delay an iteration and continue it when needed.
* Applying the pattern can be an overkill if your app only works with simple collections.
* Using an iterator may be less efficient than going through elements of some specialized collections directly.

## Interpreter

The Interpreter pattern defines a way to evaluate language grammar or expressions. It provides a way to represent the grammar of a language and interpret sentences in that language.

**When to Use:**

* When a simple language needs to be interpreted.
* When you can represent the language's syntax in a structured way (e.g., Abstract Syntax Tree).
* When you have repeated evaluation of expressions based on a set of rules or a grammar.

**How to Implement:**

1. Define the Grammar: Create a representation for the grammar, often using classes where each class represents a different type of language element (e.g., terminal and non-terminal expressions).
2. Create an Abstract Expression Interface: Define an interpret method that will be used to interpret expressions.
3. Implement Concrete Expression Classes: Create concrete classes for each grammar rule. These classes will implement the interpret method.
4. Context: Create a context class to contain information that's global to the interpreter, such as variables and their values.
5. Client: Use the interpreter to evaluate expressions by parsing the expressions and invoking the interpret method.

**Sample Implementation**

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Product {
    private final String name;
    private final String category;
    private final double price;
    private final int stock;
    
    public Product(String name, String category, double price, int stock) {
        this.name = name;
        this.category = category;
        this.price = price;
        this.stock = stock;
    }
    
    public String getCategory() {
        return category;
    }
    
    public double getPrice() {
        return price;
    }
    
    public int getStock() {
        return stock;
    }
    
    public String getName(){
        return name;
    }
    
    @Override
    public String toString(){
        return "Product{" +
            "name='" + name + '\'' +
            ", category='" + category + '\'' +
            ", price=" + price +
            ", stock=" + stock +
            '}';
    }
}

class InventoryContext {
    private final List<Product> products;
    
    public InventoryContext(List<Product> products) {
        this.products = products;
    }
    
    public List<Product> getProducts() {
        return products;
    }
}

interface Expression {
    boolean interpret(Product product);
}

class CategoryExpression implements Expression {
    private final String category;
    
    public CategoryExpression(String category) {
        this.category = category;
    }
    
    @Override
    public boolean interpret(Product product) {
        return product.getCategory().equalsIgnoreCase(category);
    }
}

class PriceRangeExpression implements Expression {
    private final double minPrice;
    private final double maxPrice;
    
    public PriceRangeExpression(double minPrice, double maxPrice) {
        this.minPrice = minPrice;
        this.maxPrice = maxPrice;
    }
    
    @Override
    public boolean interpret(Product product) {
        double price = product.getPrice();
        return price >= minPrice && price <= maxPrice;
    }
}

class StockAvailabilityExpression implements Expression {
    private final int minimumStock;
    
    public StockAvailabilityExpression(int minimumStock) {
        this.minimumStock = minimumStock;
    }
    
    @Override
    public boolean interpret(Product product) {
        return product.getStock() >= minimumStock;
    }
}

class AndExpression implements Expression {
    private final Expression expr1;
    private final Expression expr2;
    
    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }
    
    @Override
    public boolean interpret(Product product) {
        return expr1.interpret(product) && expr2.interpret(product);
    }
}

class OrExpression implements Expression {
    private final Expression expr1;
    private final Expression expr2;
    
    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }
    
    @Override
    public boolean interpret(Product product) {
        return expr1.interpret(product) || expr2.interpret(product);
    }
}

class NotExpression implements Expression {
    private final Expression expr;
    
    public NotExpression(Expression expr) {
        this.expr = expr;
    }
    
    @Override
    public boolean interpret(Product product) {
        return !expr.interpret(product);
    }
}

//Interpreter
class FluentInventoryFilter {
    private final InventoryContext inventoryContext;
    
    FluentInventoryFilter(InventoryContext inventoryContext){
        this.inventoryContext = inventoryContext;
    }
    
    List<Product> filterProductsUsing(String expression){
        Expression expressionTree = buildExpressionTree(expression);
        return inventoryContext.getProducts().stream()
            .filter(expressionTree::interpret)
            .collect(Collectors.toList());
    }
    
    private Expression buildExpressionTree(String expression){
        //mock interpretation. In real world, a separate parser must be implemented to resolve the equivalent expression tree
        return new OrExpression(
            new AndExpression(
                new CategoryExpression("Electronics"),
                new PriceRangeExpression(100, 500)
            ),
            new NotExpression(
                new StockAvailabilityExpression(5)
            )
        );
    }
}

class Scratch {
    public static void main(String[] args) {
    
        // Create context with a list of products
        InventoryContext context = new InventoryContext(Arrays.asList(
            new Product("Laptop", "Electronics", 450, 3),
            new Product("Smartphone", "Electronics", 300, 10),
            new Product("Chair", "Furniture", 80, 20)
        ));
    
        FluentInventoryFilter fluentInventoryFilter = new FluentInventoryFilter(context);
        List<Product> filteredProducts = fluentInventoryFilter.filterProductsUsing(
            "(category = 'Electronics' AND price BETWEEN 100 AND 500) OR NOT(stock >= 5)");
    
        System.out.println(filteredProducts);
    }
}

```

**Real World Examples:**

SQL Query Parsing: An interpreter pattern can be used to parse and evaluate SQL queries.
Mathematical Expression Evaluation: Calculators use the Interpreter pattern to parse and compute mathematical expressions.

**Considerations:**

* Complexity: The Interpreter pattern can become complex and hard to manage if the grammar is too complex or large.
* Performance: The pattern may be inefficient for large expressions, as it involves recursive parsing and interpretation. Consider alternative patterns or optimizations if performance is critical.
* Scalability: Adding new rules might require significant changes across multiple classes, making the system harder to scale.

## Mediator

The Mediator pattern defines an object that encapsulates how a set of objects interact. It promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.

**When to Use**

* When you have a complex set of inter-object communications that need to be simplified.
* When you want to centralize communication between objects to reduce dependencies.
* When you want to decouple the components of a system, making it easier to manage and extend.

**How to Implement**

1. Define a Mediator Interface that declares methods for communication between components.
2. Implement the Mediator Interface with a concrete class that manages the communication between components.
3. Define Colleagues (components) that communicate with each other through the mediator.
4. Implement the Colleagues to use the mediator to send messages and updates.

**Sample Implementation**

```java
// Mediator Interface
interface SupplyMediator {
    void notify(String event, InventoryItem item);
}

// Concrete Mediator
class ConcreteSupplyMediator implements SupplyMediator {
    private InventoryManager inventoryManager;
    private SupplyReplenisher supplyReplenisher;

    public void setInventoryManager(InventoryManager inventoryManager) {
        this.inventoryManager = inventoryManager;
    }

    public void setSupplyReplenisher(SupplyReplenisher supplyReplenisher) {
        this.supplyReplenisher = supplyReplenisher;
    }

    @Override
    public void notify(String event, InventoryItem item) {
        if (event.equals("lowStock")) {
            supplyReplenisher.reorder(item);
        } else if (event.equals("inventoryUpdated")) {
            inventoryManager.checkStock(item);
        }
    }
}

// Colleague 1: Inventory Manager
class InventoryManager {
    private SupplyMediator mediator;

    public InventoryManager(SupplyMediator mediator) {
        this.mediator = mediator;
    }

    public void updateStock(InventoryItem item, int quantity) {
        item.setQuantity(quantity);
        System.out.println("Updated stock for item: " + item.getName() + " to " + quantity);
        if (quantity < item.getReorderLevel()) {
            mediator.notify("lowStock", item);
        }
    }

    public void checkStock(InventoryItem item) {
        if (item.getQuantity() < item.getReorderLevel()) {
            System.out.println("Stock is low for item: " + item.getName());
            mediator.notify("lowStock", item);
        }
    }
}

// Colleague 2: Supply Replenisher
class SupplyReplenisher {
    private SupplyMediator mediator;

    public SupplyReplenisher(SupplyMediator mediator) {
        this.mediator = mediator;
    }

    public void reorder(InventoryItem item) {
        System.out.println("Reordering supply for item: " + item.getName());
        // Simulate reordering process
        // After reordering, update stock
        item.setQuantity(item.getReorderLevel() + 10); // Assume we add 10 units
        mediator.notify("inventoryUpdated", item);
    }
}

// Inventory Item
class InventoryItem {
    private String name;
    private int quantity;
    private int reorderLevel;

    public InventoryItem(String name, int quantity, int reorderLevel) {
        this.name = name;
        this.quantity = quantity;
        this.reorderLevel = reorderLevel;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public int getReorderLevel() {
        return reorderLevel;
    }
}

// Sample Usage
public class Main {
    public static void main(String[] args) {
        ConcreteSupplyMediator mediator = new ConcreteSupplyMediator();
        InventoryManager inventoryManager = new InventoryManager(mediator);
        SupplyReplenisher supplyReplenisher = new SupplyReplenisher(mediator);

        mediator.setInventoryManager(inventoryManager);
        mediator.setSupplyReplenisher(supplyReplenisher);

        InventoryItem item = new InventoryItem("Smartphone", 5, 10);

        // Simulate stock update that triggers reorder
        inventoryManager.updateStock(item, 5); // Low stock condition

        // Check if stock needs to be updated after reorder
        inventoryManager.checkStock(item);
    }
}

```

**Real World Examples**

* Chat Applications: In chat systems, a mediator can manage communication between multiple users. Instead of each user communicating directly with every other user, the mediator (chat server) handles message routing and user interactions.
* Flight Booking Systems: A mediator can coordinate interactions between different components like availability checking, booking, and payment processing systems. This ensures that each component only communicates with the mediator rather than with every other component.

**Considerations**

* The Mediator pattern can centralize complex interactions but can also become a single point of failure if not managed correctly.
* Overuse of the Mediator pattern may lead to a "God Object" problem, where the mediator itself becomes too complex and difficult to manage.