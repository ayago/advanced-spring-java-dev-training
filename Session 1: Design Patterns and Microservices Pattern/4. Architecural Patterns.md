# Architecture Patterns

Architecture patterns in software development are high-level strategies for solving common design challenges in system architecture. These patterns provide a blueprint for structuring software systems, ensuring they are scalable, maintainable, and robust. Unlike design patterns, which address specific code-level issues, architecture patterns address the broader structure and interaction between components within a system.

**Key Characteristics**

* High-Level Design: Focus on the organization and interaction of major components.
* Scalability and Performance: Consideration of how the system will perform and scale under load.
* Maintainability: Ensure that the system can be easily maintained and extended.
* Reusability: Encourage the reuse of components or services across different parts of the system.
* Separation of Concerns: Divide the system into distinct sections, each responsible for a specific concern.

## Layered Pattern

**Intent:**
The Layered Pattern, also known as the N-tier architecture, is designed to organize the components of an application into horizontal layers, each with a specific responsibility. This separation of concerns allows for more modular and maintainable code.

**When to Use:**
- When building applications that require a clear separation of concerns.
- When the application needs to be scalable, maintainable, and testable.
- When developing enterprise applications where each layer can be developed and maintained independently.

**Components Involved:**
1. **Presentation Layer (UI):** Handles user interface and user interaction.
2. **Application Layer (Service):** Manages application logic and communication between the UI and other layers.
3. **Business Logic Layer (Domain):** Contains the core functionality and business rules of the application.
4. **Data Access Layer (Persistence):** Manages data storage and retrieval, typically interacting with databases.
5. **Database Layer:** The actual database or data source where the applicationâ€™s data resides.

![Layerd Pattern](<Assets/4. Architecural Patterns/LayeredArchitecture.png>)

**Real-World Usage:**
- **ECommerce Systems:** Where the UI handles user interactions, the business logic manages product selection and purchasing rules, and the data access layer interacts with the database.
- **Enterprise Resource Planning (ERP) Systems:** Which require clear separations between the different modules, such as finance, HR, and inventory management.

**Pros:**
- **Separation of Concerns:** Each layer handles a specific part of the application, leading to more maintainable and testable code.
- **Modularity:** Layers can be developed, updated, and replaced independently.
- **Scalability:** Each layer can be scaled separately, depending on the load.

**Cons:**
- **Performance Overhead:** Multiple layers can introduce latency as data passes through each layer.
- **Complexity:** Managing dependencies and communication between layers can be complex, especially in large systems.
- **Rigidity:** Changes in one layer can sometimes require changes in others, making the architecture less flexible.

## Broker Pattern

**Intent:**
The Broker Pattern is designed to structure distributed systems with decoupled components that interact by remote service invocations. The broker is responsible for coordinating communication between clients and servers, managing the complexity of these interactions.

**When to Use:**
- When building distributed systems where components need to interact with each other remotely.
- When you need to decouple clients and servers to enable independent development and scaling.
- When you require a standardized communication mechanism in a heterogeneous network.

**Components Involved:**
1. **Client:** Initiates requests for services. The client does not need to know the details of the server providing the service.
2. **Server:** Provides services in response to client requests. The server is unaware of the clients requesting services.
3. **Broker:** Manages communication between clients and servers, handling requests, responses, and any necessary service discovery or load balancing.
4. **Stub (Proxy):** Represents the client on the server side, handling communication with the broker.
5. **Skeleton:** Represents the server on the client side, interacting with the broker to fulfill service requests.

![Broker Pattern](<Assets/4. Architecural Patterns/BrokerPattern.jpg>)

**Real-World Usage:**

- **Distributed File Systems (e.g., Hadoop HDFS):** In distributed file systems, a broker or name node manages metadata and coordinates access to file data across a cluster of storage nodes. Clients interact with the broker to locate and access the files without needing to know the specifics of the underlying storage nodes.

- **Remote Procedure Call (RPC) Frameworks (e.g., gRPC):** RPC frameworks use a broker-like mechanism to handle requests and responses between clients and servers. The framework manages the communication protocol, serialization, and deserialization of messages, allowing developers to focus on business logic rather than communication details.

**Pros:**
- **Decoupling:** Clients and servers are independent, making it easier to develop, scale, and maintain each component separately.
- **Flexibility:** Supports heterogeneous systems, allowing components written in different languages or running on different platforms to communicate.
- **Scalability:** The broker can manage load balancing and service discovery, enabling the system to scale easily.

**Cons:**
- **Complexity:** Introducing a broker adds additional layers of complexity to the system.
- **Performance Overhead:** Communication through a broker can introduce latency and may become a bottleneck if not properly managed.
- **Single Point of Failure:** The broker can become a single point of failure unless redundancy and fault tolerance are implemented.

### Blackboard Pattern

**Intent:**
The Blackboard Pattern is designed for problems where multiple, diverse solutions are applied to a shared set of data. It provides a framework for iterative problem-solving by allowing various independent components (called knowledge sources) to contribute to a global solution.

**When to Use:**
- When solving complex problems that require the integration of different approaches or expertise.
- When the solution involves incremental refinements and contributions from multiple sources.
- When dealing with a problem domain where solutions are not straightforward and require a dynamic, collaborative approach.

**Components Involved:**
1. **Blackboard:** A central repository where data or problem states are stored. It serves as the shared workspace for knowledge sources.
2. **Knowledge Sources:** Independent components or modules that contribute to the solution by reading from and writing to the blackboard. They operate based on the current state of the blackboard.
3. **Controller:** Manages the interaction between the blackboard and knowledge sources. It coordinates the application of knowledge sources and the flow of data within the system.
   
![Blackboard Pattern](<Assets/4. Architecural Patterns/BlackboardPattern.png>)

**Real-World Usage:**
- **Expert Systems:** Such as medical diagnosis systems where different expert modules (e.g., symptom analysis, medical history, treatment recommendations) contribute to diagnosing and recommending treatments based on shared patient data.
- **Speech Recognition Systems:** Where different algorithms or models (e.g., phoneme recognition, language modeling, acoustic modeling) work together on the blackboard to improve accuracy and transcription.
- **Design Optimization:** In engineering, where various optimization techniques and heuristics (e.g., structural analysis, material selection, cost estimation) iteratively refine a design solution on a shared blackboard.

**Pros:**
- **Flexibility:** Allows multiple, diverse approaches to contribute to the solution, making it adaptable to complex problems.
- **Incremental Improvement:** Supports iterative refinement and improvement as new knowledge sources contribute to the blackboard.
- **Decoupling:** Knowledge sources are loosely coupled with the blackboard, making it easier to add, modify, or remove sources without impacting others.

**Cons:**
- **Complexity:** The interaction between the blackboard, knowledge sources, and controller can be complex and hard to manage.
- **Performance Overhead:** Frequent read/write operations to the blackboard can introduce performance bottlenecks, especially with large or complex data sets.
- **Coordination:** Requires careful management of the coordination and sequencing of knowledge sources to ensure coherent and effective problem-solving.

