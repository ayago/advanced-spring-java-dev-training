# Architecture Patterns

Architecture patterns in software development are high-level strategies for solving common design challenges in system architecture. These patterns provide a blueprint for structuring software systems, ensuring they are scalable, maintainable, and robust. Unlike design patterns, which address specific code-level issues, architecture patterns address the broader structure and interaction between components within a system.

**Key Characteristics**

* High-Level Design: Focus on the organization and interaction of major components.
* Scalability and Performance: Consideration of how the system will perform and scale under load.
* Maintainability: Ensure that the system can be easily maintained and extended.
* Reusability: Encourage the reuse of components or services across different parts of the system.
* Separation of Concerns: Divide the system into distinct sections, each responsible for a specific concern.

## Layered Pattern

**Intent:**
The Layered Pattern, also known as the N-tier architecture, is designed to organize the components of an application into horizontal layers, each with a specific responsibility. This separation of concerns allows for more modular and maintainable code.

**When to Use:**
- When building applications that require a clear separation of concerns.
- When the application needs to be scalable, maintainable, and testable.
- When developing enterprise applications where each layer can be developed and maintained independently.

**Components Involved:**
1. **Presentation Layer (UI):** Handles user interface and user interaction.
2. **Application Layer (Service):** Manages application logic and communication between the UI and other layers.
3. **Business Logic Layer (Domain):** Contains the core functionality and business rules of the application.
4. **Data Access Layer (Persistence):** Manages data storage and retrieval, typically interacting with databases.
5. **Database Layer:** The actual database or data source where the applicationâ€™s data resides.

![Layerd Pattern](<Assets/4. Architecural Patterns/LayeredArchitecture.png>)

**Real-World Usage:**
- **ECommerce Systems:** Where the UI handles user interactions, the business logic manages product selection and purchasing rules, and the data access layer interacts with the database.
- **Enterprise Resource Planning (ERP) Systems:** Which require clear separations between the different modules, such as finance, HR, and inventory management.

**Pros:**
- **Separation of Concerns:** Each layer handles a specific part of the application, leading to more maintainable and testable code.
- **Modularity:** Layers can be developed, updated, and replaced independently.
- **Scalability:** Each layer can be scaled separately, depending on the load.

**Cons:**
- **Performance Overhead:** Multiple layers can introduce latency as data passes through each layer.
- **Complexity:** Managing dependencies and communication between layers can be complex, especially in large systems.
- **Rigidity:** Changes in one layer can sometimes require changes in others, making the architecture less flexible.

## Broker Pattern

**Intent:**
The Broker Pattern is designed to structure distributed systems with decoupled components that interact by remote service invocations. The broker is responsible for coordinating communication between clients and servers, managing the complexity of these interactions.

**When to Use:**
- When building distributed systems where components need to interact with each other remotely.
- When you need to decouple clients and servers to enable independent development and scaling.
- When you require a standardized communication mechanism in a heterogeneous network.

**Components Involved:**
1. **Client:** Initiates requests for services. The client does not need to know the details of the server providing the service.
2. **Server:** Provides services in response to client requests. The server is unaware of the clients requesting services.
3. **Broker:** Manages communication between clients and servers, handling requests, responses, and any necessary service discovery or load balancing.
4. **Stub (Proxy):** Represents the client on the server side, handling communication with the broker.
5. **Skeleton:** Represents the server on the client side, interacting with the broker to fulfill service requests.

**Real-World Usage:**

- **Distributed File Systems (e.g., Hadoop HDFS):** In distributed file systems, a broker or name node manages metadata and coordinates access to file data across a cluster of storage nodes. Clients interact with the broker to locate and access the files without needing to know the specifics of the underlying storage nodes.

- **Remote Procedure Call (RPC) Frameworks (e.g., gRPC):** RPC frameworks use a broker-like mechanism to handle requests and responses between clients and servers. The framework manages the communication protocol, serialization, and deserialization of messages, allowing developers to focus on business logic rather than communication details.

![alt text](<Assets/4. Architecural Patterns/BrokerPattern.jpg>)

**Pros:**
- **Decoupling:** Clients and servers are independent, making it easier to develop, scale, and maintain each component separately.
- **Flexibility:** Supports heterogeneous systems, allowing components written in different languages or running on different platforms to communicate.
- **Scalability:** The broker can manage load balancing and service discovery, enabling the system to scale easily.

**Cons:**
- **Complexity:** Introducing a broker adds additional layers of complexity to the system.
- **Performance Overhead:** Communication through a broker can introduce latency and may become a bottleneck if not properly managed.
- **Single Point of Failure:** The broker can become a single point of failure unless redundancy and fault tolerance are implemented.
