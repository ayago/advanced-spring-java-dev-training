# Behavioral Patterns

Behavioral patterns are concerned with algorithms and theassignment of
responsibilities between objects. Behavioral patterns describe not just patterns
of objects or classes but also the patterns of communication between them. These
patterns characterize complex control flow that's difficult to follow at run-time.
They shift your focus away from flow of control to let you concentrate just on the way objects are interconnected.

## Chain of Responsibility

A behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**When to Use:**

* When you have multiple objects that can handle a request but the exact handler isn’t known in advance.
* When you want to avoid tight coupling between a sender and multiple receivers.
* When you want to execute different operations in sequence on an event but in a loosely coupled manner.

**How to Implement:**

1. Define a Handler Interface: Create an interface or abstract class defining a method to process the request and a reference to the next handler.
2. Concrete Handlers: Implement concrete classes for each type of handler in the chain. Each handler decides whether to process the request or pass it to the next handler.
3. Client: The client initiates the request and passes it to the first handler in the chain.
4. Chain Setup: Link handlers together in the desired order.

**Sample Implementation**

An eCommerce system must decide the appropriate delivery channel for an order based on its properties.

```java
// Order Interface
interface Order {
    boolean isStandardEligible();
    boolean isExpressEligible();
    boolean isInternational();
}

// MockOrder Class
class MockOrder implements Order {
    private boolean standardEligible;
    private boolean expressEligible;
    private boolean international;

    public MockOrder(boolean standardEligible, boolean expressEligible, boolean international) {
        this.standardEligible = standardEligible;
        this.expressEligible = expressEligible;
        this.international = international;
    }

    @Override
    public boolean isStandardEligible() {
        return standardEligible;
    }

    @Override
    public boolean isExpressEligible() {
        return expressEligible;
    }

    @Override
    public boolean isInternational() {
        return international;
    }
}

// Abstract Handler Class
abstract class DeliveryChannelHandler {
    private DeliveryChannelHandler next;

    public void setNextHandler(DeliveryChannelHandler next) {
        this.next = next;
    }

    public void handle(Order order) {
        if (canHandle(order)) {
            doHandle(order);
        } else if (next != null) {
            next.handle(order);
        } else {
            System.out.println("No suitable delivery channel found.");
        }
    }

    protected abstract boolean canHandle(Order order);
    protected abstract void doHandle(Order order);
}

// Concrete Handlers

class StandardDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isStandardEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Standard Delivery.");
    }
}

class ExpressDeliveryHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isExpressEligible();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via Express Delivery.");
    }
}

class InternationalShippingHandler extends DeliveryChannelHandler {
    @Override
    protected boolean canHandle(Order order) {
        return order.isInternational();
    }

    @Override
    protected void doHandle(Order order) {
        System.out.println("Order will be shipped via International Shipping.");
    }
}

// DeliveryChannelChain Class
class DeliveryChannelChain {
    private DeliveryChannelHandler firstHandler;

    public DeliveryChannelChain(DeliveryChannelHandler... handlers) {
        if (handlers.length > 0) {
            this.firstHandler = handlers[0];
            DeliveryChannelHandler current = firstHandler;

            for (int i = 1; i < handlers.length; i++) {
                current.setNextHandler(handlers[i]);
                current = handlers[i];
            }
        }
    }

    public DeliveryChannelHandler getChainedHandler(){
        return this.firstHandler;
    }
}

// Client - Name the file ECommerceDelivery.java to execute this sample
public class ECommerceDelivery {
    public static void main(String[] args) {
        
        DeliveryChannelChain deliveryChain = new DeliveryChannelChain(
            new StandardDeliveryHandler(), 
            new ExpressDeliveryHandler(), 
            new InternationalShippingHandler()
        );

        Order order = new MockOrder(false, true, false); // Mock order

        deliveryChain.getChainedHandler().handle(order); // Start the decision chain
    }
}

```

**Real-World Examples:**

* Customer Support System: An email sent to customer support may pass through various levels of support (e.g., Level 1, Level 2, Technical Support) until the issue is resolved.
* Logging Framework: In a logging framework, log requests may pass through different loggers (console, file, database) until one of them handles the logging request.
* Spring Security Filters

**Considerations:**

* Performance: If the chain is too long, it may introduce latency, especially if each handler performs an expensive operation.
* Order Dependency: The order of handlers in the chain is crucial as it directly affects the outcome. The wrong order may lead to improper handling of requests.
* Flexible but Potentially Hard to Trace: While decoupling makes the system more flexible, it can make debugging harder since the request could be handled by any handler in the chain.

## Command

Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request’s execution, and support undoable operations.

**When to Use**

* You need to parameterize objects with operations.
* You want to queue, log, schedule, or provide undo functionality for operations.
* You want to decouple the sender of a request from the object that performs the action.

**How to Implement**

1. Command Interface: Define a command interface with a method for executing the command.
2. Concrete Command: Implement the command interface for each specific operation.
Receiver: Implement the actual logic that performs the operation.
3. Invoker: This class triggers the command execution.
4. Client/Application: The client creates the command object, sets the receiver, and passes the command to the invoker.

**Sample Implementation**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Command Interface
interface Command {
    void execute();
}

// Receiver
class InventoryService {
    public void addItem(String item) {
        System.out.println("Item " + item + " added to inventory.");
    }

    public void removeItem(String item) {
        System.out.println("Item " + item + " removed from inventory.");
    }
}

// Concrete Command for Adding Item
class AddItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public AddItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.addItem(item);
    }
}

// Concrete Command for Removing Item
class RemoveItemCommand implements Command {
    private InventoryService inventoryService;
    private String item;

    public RemoveItemCommand(InventoryService inventoryService, String item) {
        this.inventoryService = inventoryService;
        this.item = item;
    }

    @Override
    public void execute() {
        inventoryService.removeItem(item);
    }
}

// Invoker
class InventoryManager {
    private ExecutorService executorService;

    public InventoryManager(int threadPoolSize) {
        this.executorService = Executors.newFixedThreadPool(threadPoolSize);
    }

    public void executeCommand(Command command) {
        executorService.submit(() -> {
            command.execute();
        });
    }

    // Gracefully shut down the executor service when done
    public void shutdown() {
        executorService.shutdown();
    }
}

// Client/Application
public class ECommerceApp {
    public static void main(String[] args) {
        InventoryService inventoryService = new InventoryService();
        Command addCommand = new AddItemCommand(inventoryService, "Laptop");
        Command removeCommand = new RemoveItemCommand(inventoryService, "Laptop");

        // Create InventoryManager with a thread pool of size 2
        InventoryManager manager = new InventoryManager(2);

        // Execute commands asynchronously
        manager.executeCommand(addCommand);
        manager.executeCommand(removeCommand);

        // Shutdown the executor when done
        manager.shutdown();
    }
}

```

**Real World Examples**

* GUI Frameworks: Buttons and menu items in graphical user interfaces often use Command patterns to handle user actions like opening files or saving documents.
* Task Scheduling: In scheduling systems, tasks are encapsulated as commands and then executed by a task scheduler.
* The Java Runnable interface

**Considerations**

* Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations.
* Open/Closed Principle. You can introduce new commands into the app without breaking existing client code.
* You can implement undo/redo.
* You can implement deferred execution of operations.
* You can assemble a set of simple commands into a complex one.
* The code may become more complicated since you’re introducing a whole new layer between senders and receivers.

## Iterator

The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

**When to Use**

When you need to traverse a collection of objects without exposing the internal structure.
When multiple types of collections need to be iterated in a uniform way.
When different traversal algorithms are required for different data structures.

**How to Implement**

1. Define the Iterator Interface: Define an interface with methods like hasNext(), next(), and optionally remove().
2. Concrete Iterator: Implement the iterator interface for specific collections.
3. Aggregate Interface: Create an interface to define a method that returns an iterator, e.g., createIterator().
4. Concrete Aggregate: Implement the aggregate interface, which returns the specific iterator for the collection.

**Sample Implementation**

```java
import java.util.*;

// Iterator Interface
public interface InventoryIterator extends AutoCloseable {
    boolean hasNext();
    InventoryItem next();
    @Override
    void close();
}

// Concrete Iterator for Event Stream
public class EventStreamIterator implements InventoryIterator {
    private Queue<InventoryItem> eventStream;

    public EventStreamIterator(Queue<InventoryItem> eventStream) {
        this.eventStream = eventStream;
    }

    @Override
    public boolean hasNext() {
        return !eventStream.isEmpty();
    }

    @Override
    public InventoryItem next() {
        return eventStream.poll();
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("EventStreamIterator: Closing resources.");
    }
}

// Concrete Iterator for Bulk Fetch
public class BulkFetchIterator implements InventoryIterator {
    private List<InventoryItem> items;
    private int currentPosition = 0;

    public BulkFetchIterator(List<InventoryItem> items) {
        this.items = items;
    }

    @Override
    public boolean hasNext() {
        return currentPosition < items.size();
    }

    @Override
    public InventoryItem next() {
        return items.get(currentPosition++);
    }

    @Override
    public void close() {
        // Simulate closing or cleaning up resources
        System.out.println("BulkFetchIterator: Closing resources.");
    }
}

// Aggregate Interface
public interface InventoryAggregate {
    InventoryIterator createIterator();
}

// Concrete Aggregate for Event Stream
public class EventStreamInventory implements InventoryAggregate {
    private Queue<InventoryItem> eventStream = new LinkedList<>();

    public void addEvent(InventoryItem item) {
        eventStream.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new EventStreamIterator(eventStream);
    }
}

// Concrete Aggregate for Bulk Fetch
public class BulkFetchInventory implements InventoryAggregate {
    private List<InventoryItem> items = new ArrayList<>();

    public void addItem(InventoryItem item) {
        items.add(item);
    }

    @Override
    public InventoryIterator createIterator() {
        return new BulkFetchIterator(items);
    }
}

// InventoryItem Class
public class InventoryItem {
    private String name;
    private int quantity;

    public InventoryItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Item: " + name + ", Quantity: " + quantity;
    }
}

// Main Class to demonstrate the Iterator pattern
public class InventoryOnboardingSystem {
    public static void main(String[] args) {
        // Setup Event Stream Inventory
        EventStreamInventory eventStreamInventory = new EventStreamInventory();
        eventStreamInventory.addEvent(new InventoryItem("Laptop", 50));
        eventStreamInventory.addEvent(new InventoryItem("Smartphone", 200));
        eventStreamInventory.addEvent(new InventoryItem("Tablet", 100));

        // Setup Bulk Fetch Inventory
        BulkFetchInventory bulkFetchInventory = new BulkFetchInventory();
        bulkFetchInventory.addItem(new InventoryItem("Monitor", 75));
        bulkFetchInventory.addItem(new InventoryItem("Keyboard", 150));
        bulkFetchInventory.addItem(new InventoryItem("Mouse", 300));

        // Process Event Stream Inventory
        System.out.println("Processing Event Stream Inventory:");
        try (InventoryIterator eventStreamIterator = eventStreamInventory.createIterator()) {
            while (eventStreamIterator.hasNext()) {
                InventoryItem item = eventStreamIterator.next();
                System.out.println(item);
            }
        }

        // Process Bulk Fetch Inventory
        System.out.println("\nProcessing Bulk Fetch Inventory:");
        try (InventoryIterator bulkFetchIterator = bulkFetchInventory.createIterator()) {
            while (bulkFetchIterator.hasNext()) {
                InventoryItem item = bulkFetchIterator.next();
                System.out.println(item);
            }
        }
    }
}

```

**Real World Example**

* Java’s java.util.Iterator: The standard library’s Iterator is a classic example. It’s used to traverse collections like List, Set, etc., without exposing their internal structures.
* Apache Kafka Consumer: The consumer API provides an iterator-like mechanism to traverse records from a Kafka topic.

**Considerations**

* Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.
* Open/Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything.
* You can iterate over the same collection in parallel because each iterator object contains its own iteration state.
* For the same reason, you can delay an iteration and continue it when needed.
* Applying the pattern can be an overkill if your app only works with simple collections.
* Using an iterator may be less efficient than going through elements of some specialized collections directly.

## Interpreter

The Interpreter pattern defines a way to evaluate language grammar or expressions. It provides a way to represent the grammar of a language and interpret sentences in that language.

**When to Use:**

* When a simple language needs to be interpreted.
* When you can represent the language's syntax in a structured way (e.g., Abstract Syntax Tree).
* When you have repeated evaluation of expressions based on a set of rules or a grammar.

**How to Implement:**

1. Define the Grammar: Create a representation for the grammar, often using classes where each class represents a different type of language element (e.g., terminal and non-terminal expressions).
2. Create an Abstract Expression Interface: Define an interpret method that will be used to interpret expressions.
3. Implement Concrete Expression Classes: Create concrete classes for each grammar rule. These classes will implement the interpret method.
4. Context: Create a context class to contain information that's global to the interpreter, such as variables and their values.
5. Client: Use the interpreter to evaluate expressions by parsing the expressions and invoking the interpret method.

**Sample Implementation**

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Product {
    private final String name;
    private final String category;
    private final double price;
    private final int stock;
    
    public Product(String name, String category, double price, int stock) {
        this.name = name;
        this.category = category;
        this.price = price;
        this.stock = stock;
    }
    
    public String getCategory() {
        return category;
    }
    
    public double getPrice() {
        return price;
    }
    
    public int getStock() {
        return stock;
    }
    
    public String getName(){
        return name;
    }
    
    @Override
    public String toString(){
        return "Product{" +
            "name='" + name + '\'' +
            ", category='" + category + '\'' +
            ", price=" + price +
            ", stock=" + stock +
            '}';
    }
}

class InventoryContext {
    private final List<Product> products;
    
    public InventoryContext(List<Product> products) {
        this.products = products;
    }
    
    public List<Product> getProducts() {
        return products;
    }
}

interface Expression {
    boolean interpret(Product product);
}

class CategoryExpression implements Expression {
    private final String category;
    
    public CategoryExpression(String category) {
        this.category = category;
    }
    
    @Override
    public boolean interpret(Product product) {
        return product.getCategory().equalsIgnoreCase(category);
    }
}

class PriceRangeExpression implements Expression {
    private final double minPrice;
    private final double maxPrice;
    
    public PriceRangeExpression(double minPrice, double maxPrice) {
        this.minPrice = minPrice;
        this.maxPrice = maxPrice;
    }
    
    @Override
    public boolean interpret(Product product) {
        double price = product.getPrice();
        return price >= minPrice && price <= maxPrice;
    }
}

class StockAvailabilityExpression implements Expression {
    private final int minimumStock;
    
    public StockAvailabilityExpression(int minimumStock) {
        this.minimumStock = minimumStock;
    }
    
    @Override
    public boolean interpret(Product product) {
        return product.getStock() >= minimumStock;
    }
}

class AndExpression implements Expression {
    private final Expression expr1;
    private final Expression expr2;
    
    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }
    
    @Override
    public boolean interpret(Product product) {
        return expr1.interpret(product) && expr2.interpret(product);
    }
}

class OrExpression implements Expression {
    private final Expression expr1;
    private final Expression expr2;
    
    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }
    
    @Override
    public boolean interpret(Product product) {
        return expr1.interpret(product) || expr2.interpret(product);
    }
}

class NotExpression implements Expression {
    private final Expression expr;
    
    public NotExpression(Expression expr) {
        this.expr = expr;
    }
    
    @Override
    public boolean interpret(Product product) {
        return !expr.interpret(product);
    }
}

//Interpreter
class FluentInventoryFilter {
    private final InventoryContext inventoryContext;
    
    FluentInventoryFilter(InventoryContext inventoryContext){
        this.inventoryContext = inventoryContext;
    }
    
    List<Product> filterProductsUsing(String expression){
        Expression expressionTree = buildExpressionTree(expression);
        return inventoryContext.getProducts().stream()
            .filter(expressionTree::interpret)
            .collect(Collectors.toList());
    }
    
    private Expression buildExpressionTree(String expression){
        //mock interpretation. In real world, a separate parser must be implemented to resolve the equivalent expression tree
        return new OrExpression(
            new AndExpression(
                new CategoryExpression("Electronics"),
                new PriceRangeExpression(100, 500)
            ),
            new NotExpression(
                new StockAvailabilityExpression(5)
            )
        );
    }
}

class Scratch {
    public static void main(String[] args) {
    
        // Create context with a list of products
        InventoryContext context = new InventoryContext(Arrays.asList(
            new Product("Laptop", "Electronics", 450, 3),
            new Product("Smartphone", "Electronics", 300, 10),
            new Product("Chair", "Furniture", 80, 20)
        ));
    
        FluentInventoryFilter fluentInventoryFilter = new FluentInventoryFilter(context);
        List<Product> filteredProducts = fluentInventoryFilter.filterProductsUsing(
            "(category = 'Electronics' AND price BETWEEN 100 AND 500) OR NOT(stock >= 5)");
    
        System.out.println(filteredProducts);
    }
}

```

**Real World Examples:**

SQL Query Parsing: An interpreter pattern can be used to parse and evaluate SQL queries.
Mathematical Expression Evaluation: Calculators use the Interpreter pattern to parse and compute mathematical expressions.

**Considerations:**

* Complexity: The Interpreter pattern can become complex and hard to manage if the grammar is too complex or large.
* Performance: The pattern may be inefficient for large expressions, as it involves recursive parsing and interpretation. Consider alternative patterns or optimizations if performance is critical.
* Scalability: Adding new rules might require significant changes across multiple classes, making the system harder to scale.

## Mediator

The Mediator pattern defines an object that encapsulates how a set of objects interact. It promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.

**When to Use**

* When you have a complex set of inter-object communications that need to be simplified.
* When you want to centralize communication between objects to reduce dependencies.
* When you want to decouple the components of a system, making it easier to manage and extend.

**How to Implement**

1. Define a Mediator Interface that declares methods for communication between components.
2. Implement the Mediator Interface with a concrete class that manages the communication between components.
3. Define Colleagues (components) that communicate with each other through the mediator.
4. Implement the Colleagues to use the mediator to send messages and updates.

**Sample Implementation**

```java
// Mediator Interface
interface SupplyMediator {
    void notify(String event, InventoryItem item);
}

// Concrete Mediator
class ConcreteSupplyMediator implements SupplyMediator {
    private InventoryManager inventoryManager;
    private SupplyReplenisher supplyReplenisher;

    public void setInventoryManager(InventoryManager inventoryManager) {
        this.inventoryManager = inventoryManager;
    }

    public void setSupplyReplenisher(SupplyReplenisher supplyReplenisher) {
        this.supplyReplenisher = supplyReplenisher;
    }

    @Override
    public void notify(String event, InventoryItem item) {
        if (event.equals("lowStock")) {
            supplyReplenisher.reorder(item);
        } else if (event.equals("inventoryUpdated")) {
            inventoryManager.checkStock(item);
        }
    }
}

// Colleague 1: Inventory Manager
class InventoryManager {
    private SupplyMediator mediator;

    public InventoryManager(SupplyMediator mediator) {
        this.mediator = mediator;
    }

    public void updateStock(InventoryItem item, int quantity) {
        item.setQuantity(quantity);
        System.out.println("Updated stock for item: " + item.getName() + " to " + quantity);
        if (quantity < item.getReorderLevel()) {
            mediator.notify("lowStock", item);
        }
    }

    public void checkStock(InventoryItem item) {
        if (item.getQuantity() < item.getReorderLevel()) {
            System.out.println("Stock is low for item: " + item.getName());
            mediator.notify("lowStock", item);
        }
    }
}

// Colleague 2: Supply Replenisher
class SupplyReplenisher {
    private SupplyMediator mediator;

    public SupplyReplenisher(SupplyMediator mediator) {
        this.mediator = mediator;
    }

    public void reorder(InventoryItem item) {
        System.out.println("Reordering supply for item: " + item.getName());
        // Simulate reordering process
        // After reordering, update stock
        item.setQuantity(item.getReorderLevel() + 10); // Assume we add 10 units
        mediator.notify("inventoryUpdated", item);
    }
}

// Inventory Item
class InventoryItem {
    private String name;
    private int quantity;
    private int reorderLevel;

    public InventoryItem(String name, int quantity, int reorderLevel) {
        this.name = name;
        this.quantity = quantity;
        this.reorderLevel = reorderLevel;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public int getReorderLevel() {
        return reorderLevel;
    }
}

// Sample Usage
public class Main {
    public static void main(String[] args) {
        ConcreteSupplyMediator mediator = new ConcreteSupplyMediator();
        InventoryManager inventoryManager = new InventoryManager(mediator);
        SupplyReplenisher supplyReplenisher = new SupplyReplenisher(mediator);

        mediator.setInventoryManager(inventoryManager);
        mediator.setSupplyReplenisher(supplyReplenisher);

        InventoryItem item = new InventoryItem("Smartphone", 5, 10);

        // Simulate stock update that triggers reorder
        inventoryManager.updateStock(item, 5); // Low stock condition

        // Check if stock needs to be updated after reorder
        inventoryManager.checkStock(item);
    }
}

```

**Real World Examples**

* Chat Applications: In chat systems, a mediator can manage communication between multiple users. Instead of each user communicating directly with every other user, the mediator (chat server) handles message routing and user interactions.
* Flight Booking Systems: A mediator can coordinate interactions between different components like availability checking, booking, and payment processing systems. This ensures that each component only communicates with the mediator rather than with every other component.

**Considerations**

* The Mediator pattern can centralize complex interactions but can also become a single point of failure if not managed correctly.
* Overuse of the Mediator pattern may lead to a "God Object" problem, where the mediator itself becomes too complex and difficult to manage.

## Memento

To capture and externalize an object's internal state without violating encapsulation, so that the object can be restored to that state later.

**When to Use**

Use the Memento pattern when you need to provide a way to restore an object to a previous state, especially when that state is complex and encapsulated. This is useful for undo mechanisms, versioning, or rollback scenarios.

**How to Implement**

1. Originator: The object whose state needs to be saved and restored. It creates a memento to capture its state.
2. Memento: A snapshot of the Originator’s state. It should be immutable or at least not exposed for modification.
3. Caretaker: Manages and stores the mementos. It doesn’t modify or inspect the contents of a memento.

**Sample Implementation**

```java
// Memento class
public class CartMemento {
    private final CartState cartState;

    public CartMemento(CartState cartState) {
        this.cartState = new CartState(cartState);
    }

    public CartState getCartState() {
        return cartState;
    }
}

// Originator class
public class ShoppingCart {
    private CartState cartState = new CartState();

    public void addItem(String item) {
        cartState.addItem(item);
    }

    public CartMemento save() {
        return new CartMemento(cartState);
    }

    public void restore(CartMemento memento) {
        this.cartState = memento.getCartState();
    }

    @Override
    public String toString() {
        return "ShoppingCart{" + cartState + "}";
    }
}

// CartState class
public class CartState {
    private final List<String> items;

    public CartState() {
        this.items = new ArrayList<>();
    }

    public CartState(CartState state) {
        this.items = new ArrayList<>(state.items);
    }

    public void addItem(String item) {
        items.add(item);
    }

    @Override
    public String toString() {
        return "CartState{items=" + items + "}";
    }
}

// Caretaker class
public class CartCaretaker {
    private final List<CartMemento> mementoList = new ArrayList<>();

    public void saveState(ShoppingCart cart) {
        mementoList.add(cart.save());
    }

    public void restoreState(ShoppingCart cart, int index) {
        if (index >= 0 && index < mementoList.size()) {
            cart.restore(mementoList.get(index));
        }
    }
}

// Main method to demonstrate usage
public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        CartCaretaker caretaker = new CartCaretaker();

        // Adding items to the cart and saving state
        cart.addItem("Laptop");
        cart.addItem("Mouse");
        System.out.println("Current Cart: " + cart);
        caretaker.saveState(cart);

        cart.addItem("Keyboard");
        System.out.println("Cart after adding Keyboard: " + cart);

        // Restoring to previous state
        caretaker.restoreState(cart, 0);
        System.out.println("Restored Cart: " + cart);
    }
}

```

**Real World Examples**

* Text Editor: A text editor with undo/redo functionality uses the Memento pattern to save the state of the document and restore it when needed.
* Game Save Systems: In video games, players’ progress and game states are saved periodically so that they can return to a previous state if needed.
  
**Considerations**

* Memory Usage: Storing multiple mementos can consume a lot of memory if the state is large or if there are many save points.
* Encapsulation: Ensure that mementos only expose what’s necessary and don’t violate the encapsulation of the Originator.
* Complexity: Managing mementos and ensuring that they are consistent with the Originator’s state can add complexity to the system.
* The Memento pattern is particularly useful in scenarios where you need to maintain historical states or provide undo functionality without exposing the internal details of the object’s state.

## Observer

The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is used to enable a subscription mechanism to allow multiple objects to listen and react to events or changes in another object.

**When to Use**

* When a change to one object requires changing others, and you don’t know how many objects need to be changed.
* When an object should be able to notify other objects without making assumptions about who or what those objects are.

**How to Implement**

1. Subject: The object that maintains a list of its dependents, called observers. It provides methods to attach and detach observers.
2. Observer: The interface or abstract class that defines the update method, which will be called by the subject.
3. Concrete Subject: A subclass of the subject that sends notifications to its observers when its state changes.
4. Concrete Observer: A subclass of the observer that updates its state based on the notifications from the subject.

**Sample Implementation**

```java
import java.util.ArrayList;
import java.util.List;

// Subject
interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

// Concrete Subject
class Customer implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private List<String> cart = new ArrayList<>();
    private String promotion;

    public void addItemToCart(String item) {
        cart.add(item);
        notifyObservers();
    }

    public List<String> getCart() {
        return cart;
    }

    public void setPromotion(String promotion) {
        this.promotion = promotion;
        notifyObservers();
    }

    public String getPromotion() {
        return promotion;
    }

    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

// Observer
interface Observer {
    void update(Subject subject);
}

// Concrete Observer
class MarketingTeam implements Observer {
    @Override
    public void update(Subject subject) {
        if (subject instanceof Customer) {
            Customer customer = (Customer) subject;
            System.out.println("Marketing Team received update: Cart contains " + customer.getCart() + " and promotion is " + customer.getPromotion());
        }
    }
}

class InventorySystem implements Observer {
    @Override
    public void update(Subject subject) {
        if (subject instanceof Customer) {
            Customer customer = (Customer) subject;
            System.out.println("Inventory System received update: Cart contains " + customer.getCart());
        }
    }
}

// Client code
public class ObserverPatternDemo {
    public static void main(String[] args) {
        Customer customer = new Customer();
        MarketingTeam marketingTeam = new MarketingTeam();
        InventorySystem inventorySystem = new InventorySystem();

        customer.attach(marketingTeam);
        customer.attach(inventorySystem);

        customer.setPromotion("50% off on all items!");
        customer.addItemToCart("Laptop");
        customer.addItemToCart("Smartphone");
    }
}

```

**Real World Examples**

* Email Marketing Systems: When a company updates its promotional offer, various marketing systems (email, SMS) need to be notified to adjust their campaigns accordingly.
* Stock Market Applications: Investors use applications that notify them of stock price changes. When the stock price changes, the application updates all registered investors.

**Considerations**

* Loose Coupling: Observers should be loosely coupled to the subjects they observe.
* Performance: If the subject has many observers, performance issues might arise due to frequent updates.
* Memory Leaks: Properly manage observer detachment to avoid memory leaks and unnecessary resource usage.

## State

Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. Closely related to the concept of a Finite-State Machine

**When to Use**

* When an object's behavior depends on its state and it must change its behavior at runtime depending on that state.
* When the code for handling state-specific behavior becomes large and complicated.

**How to Implement**

1. State Interface: Define an interface for encapsulating the state-specific behavior.
2. Concrete States: Implement the state interface in various concrete classes, each representing a different state.
3. Context: Maintain an instance of a concrete state class that represents the current state. This context delegates state-specific behavior to the current state object.
   
**Sample Implementation**

Here's a simplified implementation for an ECommerce Seller onboarding wizard:

```java
// State Interface
public interface OnboardingState {
    void handle(OnboardingContext context);
}

// Concrete States
public class GeneralDetailsEntry implements OnboardingState {
    @Override
    public void handle(OnboardingContext context) {
        System.out.println("Handling general details entry...");
        // Assuming business details include whether it's international
        if (context.isInternationalBusiness()) {
            context.setState(new LocationDetailsEntry());
        } else {
            context.setState(new ProductsRegistrationEntry());
        }
    }
}

public class BusinessRegistrationEntry implements OnboardingState {
    @Override
    public void handle(OnboardingContext context) {
        System.out.println("Handling business registration entry...");
        // Proceed to the next state
        context.setState(new GeneralDetailsEntry());
    }
}

public class LocationDetailsEntry implements OnboardingState {
    @Override
    public void handle(OnboardingContext context) {
        System.out.println("Handling location details entry...");
        context.setState(new ProductsRegistrationEntry());
    }
}

public class ProductsRegistrationEntry implements OnboardingState {
    @Override
    public void handle(OnboardingContext context) {
        System.out.println("Handling products registration entry...");
        context.setState(new ForVerification());
    }
}

public class ForVerification implements OnboardingState {
    @Override
    public void handle(OnboardingContext context) {
        System.out.println("Handling verification...");
        // End of onboarding process
    }
}

// Context
public class OnboardingContext {
    private OnboardingState state;
    private boolean internationalBusiness;

    public OnboardingContext(boolean internationalBusiness) {
        this.internationalBusiness = internationalBusiness;
        this.state = new GeneralDetailsEntry(); // Initial state
    }

    public void setState(OnboardingState state) {
        this.state = state;
    }

    public void request() {
        state.handle(this);
    }

    public boolean isInternationalBusiness() {
        return internationalBusiness;
    }
}

// Client Code
public class Main {
    public static void main(String[] args) {
        // Test with an international business
        OnboardingContext contextInternational = new OnboardingContext(true);
        contextInternational.request(); // Handles general details
        contextInternational.request(); // Handles location details
        contextInternational.request(); // Handles products registration
        contextInternational.request(); // Handles verification

        // Test with a domestic business
        OnboardingContext contextDomestic = new OnboardingContext(false);
        contextDomestic.request(); // Handles general details
        contextDomestic.request(); // Handles products registration
        contextDomestic.request(); // Handles verification
    }
}

```

**Real World Examples**

1. Document Processing: In a document editor, the state of the document (e.g., Draft, Review, Final) can change how it is handled and displayed.
2. Order Management: In an order processing system, orders can be in different states (e.g., Pending, Shipped, Delivered), and each state determines the actions that can be performed.
3. Voter Registration

**Considerations**

1. Complexity: The State pattern can introduce complexity by adding multiple state classes. Use it when the complexity of state management justifies its use.
2. State Transitions: Ensure that state transitions are well-defined and that the state objects handle transitions correctly to avoid inconsistent states.
3. Maintenance: When adding new states or transitions, ensure to update the state classes accordingly to avoid breaking the existing behavior.
4. This pattern aims to simplify the code of the context by eliminating bulky state machine conditionals.

## Strategy

Define a family of algorithms, encapsulate each one, and make them interchangeable. The Strategy pattern allows a client to choose an algorithm from a family of algorithms at runtime.

**When to Use:**

* You have multiple algorithms for a specific task and want to make them interchangeable.
* You want to vary an algorithm’s behavior dynamically without changing the context class.
You need to avoid a large number of conditional statements to select an algorithm.

**How to Implement:**

1. Context: Create a context class that uses a Strategy to perform a task.
2. Strategy Interface: Define an interface for the family of algorithms.
3. Concrete Strategies: Implement different variations of the algorithm by creating concrete classes that implement the Strategy interface.
4. Client: The client interacts with the context class to change its strategy at runtime.

**Sample Implemnentation:**

```java
// Strategy interface
public interface PricingStrategy {
    double calculatePrice(double basePrice);
}

// Concrete Strategy for Discounted Pricing
public class DiscountPricingStrategy implements PricingStrategy {
    private double discountRate;

    public DiscountPricingStrategy(double discountRate) {
        this.discountRate = discountRate;
    }

    @Override
    public double calculatePrice(double basePrice) {
        return basePrice - (basePrice * discountRate);
    }
}

// Concrete Strategy for Standard Pricing
public class StandardPricingStrategy implements PricingStrategy {
    @Override
    public double calculatePrice(double basePrice) {
        return basePrice; // No discount applied
    }
}

// Context class
public class Product {
    private PricingStrategy pricingStrategy;
    private double basePrice;

    public Product(double basePrice) {
        this.basePrice = basePrice;
    }

    public void setPricingStrategy(PricingStrategy pricingStrategy) {
        this.pricingStrategy = pricingStrategy;
    }

    public double getPrice() {
        return pricingStrategy.calculatePrice(basePrice);
    }
}

// Client code
public class Main {
    public static void main(String[] args) {
        Product product = new Product(100.0);

        // Applying Discount Pricing Strategy
        product.setPricingStrategy(new DiscountPricingStrategy(0.15));
        System.out.println("Discounted Price: " + product.getPrice());

        // Applying Standard Pricing Strategy
        product.setPricingStrategy(new StandardPricingStrategy());
        System.out.println("Standard Price: " + product.getPrice());
    }
}

```

**Real World Examples:**

* ECommerce Pricing Strategies: Online stores often use different pricing strategies, such as seasonal discounts, bulk purchase discounts, or promotional pricing. The Strategy pattern allows dynamic switching between these strategies based on the context, such as user type or special events.

* Payment Processing Systems: Payment gateways might use different algorithms for processing payments, such as credit card, PayPal, or cryptocurrency. The Strategy pattern can be used to select the appropriate payment method algorithm based on user choice or transaction type.

**Considerations:**

* Ensure that the context class is aware of the Strategy interface and can switch strategies without knowing the details of each algorithm.
* Be cautious about creating too many Strategy classes, as this could lead to a proliferation of classes.
* The Strategy pattern is beneficial when algorithms need to be varied independently of the clients that use them.

## Template Method

Define the skeleton of an algorithm in a base class, allowing subclasses to alter specific steps without changing the overall algorithm’s structure.

**When to Use:**

* You have an algorithm that can be broken down into steps, where some steps should be customizable by subclasses.
* You want to enforce a particular sequence of operations while allowing subclasses to refine certain steps.
* You want to avoid code duplication by sharing common logic across multiple subclasses.

**How to Implement:**

1. Abstract Class: Define an abstract class with a method that implements the algorithm's structure. This method is called the template method.
2. Template Method: The template method should be final or non-overridable to prevent altering the sequence of operations.
3. Primitive Operations: Define abstract or hook methods for the steps that subclasses should override or customize.
4. Concrete Subclasses: Implement the subclasses to provide specific behavior for the customizable steps.

**Sample Implementation:**

```java
// Abstract Class defining the Template Method
public abstract class OrderProcessTemplate {
    public final void processOrder() {
        selectItems();
        doPayment();
        deliverItems();
        if (isGift()) {
            wrapGift();
        }
    }

    protected abstract void selectItems();
    protected abstract void doPayment();
    protected abstract void deliverItems();

    // Hook method
    protected boolean isGift() {
        return false; // default behavior
    }

    // Optional step
    protected void wrapGift() {
        System.out.println("Wrapping gift");
    }
}

// Concrete Class for Online Orders
public class OnlineOrder extends OrderProcessTemplate {
    @Override
    protected void selectItems() {
        System.out.println("Selecting items from the online store");
    }

    @Override
    protected void doPayment() {
        System.out.println("Processing online payment");
    }

    @Override
    protected void deliverItems() {
        System.out.println("Delivering items via courier");
    }

    @Override
    protected boolean isGift() {
        return true; // override to enable gift wrapping
    }
}

// Concrete Class for In-Store Pickup Orders
public class StorePickupOrder extends OrderProcessTemplate {
    @Override
    protected void selectItems() {
        System.out.println("Selecting items in the store");
    }

    @Override
    protected void doPayment() {
        System.out.println("Paying at the counter");
    }

    @Override
    protected void deliverItems() {
        System.out.println("Handing items over at the pickup counter");
    }
}

// Client code
public class Main {
    public static void main(String[] args) {
        OrderProcessTemplate onlineOrder = new OnlineOrder();
        onlineOrder.processOrder();

        System.out.println();

        OrderProcessTemplate storePickupOrder = new StorePickupOrder();
        storePickupOrder.processOrder();
    }
}

```

**Real World Examples:**

* ECommerce Order Processing: Online shopping platforms might have different order fulfillment processes, such as home delivery, in-store pickup, or digital delivery. The Template Method pattern ensures that the core steps (selecting items, payment, delivery) remain consistent while allowing variation in how these steps are executed.
Payment Gateway Integration:

* Payment gateways often involve a sequence of steps: initiating the transaction, processing the payment, and handling the response. The Template Method pattern allows different payment providers to implement specific steps (e.g., encryption, communication protocols) while maintaining the overall transaction process structure.
  
**Considerations:**

* The Template Method pattern helps avoid code duplication by reusing the common parts of the algorithm in the base class.
* It provides a good balance between flexibility and control, allowing specific steps to be customized while maintaining overall consistency.
* Ensure that the template method is stable and changes infrequently, as frequent changes might require updating all subclasses.

## Visitor

Allows definition of new operations on objects without changing their structure. It separates an algorithm from the object structure it operates on, enabling you to add new operations without modifying the classes of the elements on which it operates.

ons without modifying the classes of the elements on which it operates.

**When to Use:**

* When you have a complex object structure, and you need to perform operations on these objects that do not naturally belong to them.
* When you anticipate the need to add new operations frequently and want to avoid modifying the underlying object structure.
* When you want to keep related operations together by defining them in one class rather than spreading them across multiple classes.

**How to Implement:**

1. Element Interface: Define an interface or abstract class for elements that can accept visitors.
2. Concrete Elements: Implement the element interface in classes representing objects within the structure.
3. Visitor Interface: Define a visitor interface with a method for each type of element in the structure.
4. Concrete Visitors: Implement the visitor interface in concrete classes, providing the desired operations.
5. Accept Method: In the concrete element classes, implement the accept method to allow a visitor to process the element.
6. Client: The client traverses the object structure and calls the accept method on each element, passing the visitor.

**Sample Implementation**

Let's consider an ECommerce Product Engagement Reporting system where we want to generate different types of reports based on various product interactions.

```java
interface Visitable {
    void accept(Visitor visitor);
}

class ProductView implements Visitable {
    private final String productId;
    private final int viewCount;

    public ProductView(String productId, int viewCount) {
        this.productId = productId;
        this.viewCount = viewCount;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String getProductId() {
        return productId;
    }

    public int getViewCount() {
        return viewCount;
    }
}

class ProductPurchase implements Visitable {
    private final String productId;
    private final int purchaseCount;

    public ProductPurchase(String productId, int purchaseCount) {
        this.productId = productId;
        this.purchaseCount = purchaseCount;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String getProductId() {
        return productId;
    }

    public int getPurchaseCount() {
        return purchaseCount;
    }
}

interface Visitor {
    void visit(Visitable visitable);
}

//Concrete visitors
class CSVReportVisitor implements Visitor {
    @Override
    public void visit(Visitable visitable) {
        switch (visitable) {
            case ProductView productView -> System.out.println("CSV Report for Product View: " 
                    + productView.getProductId() + ", Views: " + productView.getViewCount());
            case ProductPurchase productPurchase -> System.out.println("CSV Report for Product Purchase: " 
                    + productPurchase.getProductId() + ", Purchases: " + productPurchase.getPurchaseCount());
            default -> "Unsupported Metric";
        }
    }
}

class JSONReportVisitor implements Visitor {
    @Override
    public void visit(Visitable visitable) {
        switch (visitable) {
            case ProductView productView -> System.out.println("{ \"ProductId\": \"" 
                    + productView.getProductId() + "\", \"ViewCount\": " + productView.getViewCount() + " }");
            case ProductPurchase productPurchase -> System.out.println("{ \"ProductId\": \"" 
                    + productPurchase.getProductId() + "\", \"PurchaseCount\": " + productPurchase.getPurchaseCount() + " }");
            default -> "Unsupported Metric";
        }
    }
}

class ReportGenerator {
    public static void main(String[] args) {
        List<Visitable> elements = List.of(
            new ProductView("P001", 100),
            new ProductPurchase("P001", 10)
        );

        Visitor csvVisitor = new CSVReportVisitor();
        Visitor jsonVisitor = new JSONReportVisitor();

        for (Visitable element : elements) {
            element.accept(csvVisitor);
            element.accept(jsonVisitor);
        }
    }
}

```

**Real World Examples:**

* Compiler Design: The Visitor pattern is often used in compilers to traverse and operate on abstract syntax trees (ASTs). Different visitors can be created for type checking, code generation, or optimization.
* XML Document Processing: Different visitors can be used to perform operations like validation, transformation, or extraction of data from an XML document.

**Considerations:**

* Double Dispatch: The Visitor pattern relies on double dispatch to correctly identify the class of each element, which can be tricky in some languages.
* Adding New Element Classes: While the Visitor pattern makes it easy to add new operations, it makes it harder to add new element classes since every visitor will need to implement a visit method for the new element.
* Complexity: Overuse of the Visitor pattern can lead to code that is difficult to maintain, especially with a large number of elements and visitors.